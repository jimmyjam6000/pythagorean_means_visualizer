<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pythagorean Means</title>
  <style>
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:#fff; color:#111; }
    .wrap{ max-width:1100px; margin:0 auto; padding:16px; display:grid; grid-template-columns:1.2fr 0.8fr; gap:16px; }
    .card{ border:1px solid #e6e6e6; border-radius:14px; padding:14px; background:#fff; }
    h1{ font-size:18px; margin:0 0 8px; }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    label{ font-size:14px; color:#333; }
    input[type="range"]{ width:360px; }
    .mono{ font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; }
    .kv{ display:grid; grid-template-columns:1fr auto; gap:6px 12px; margin-top:10px; }
    .eq{ white-space:pre; font-size:13px; color:#333; line-height:1.55; }
    svg{ width:100%; height:auto; display:block; }
    .badge{ font-size:12px; border:1px solid #ddd; border-radius:999px; padding:2px 8px; color:#333; }
    .hint{ margin-top:10px; font-size:13px; color:#444; }
  </style>
</head>
<body>
<div class="wrap">
  <!-- LEFT: diagram -->
  <div class="card">
    <div class="row" style="justify-content:space-between;">
      <h1>Wikipedia-style Pythagorean Means (radius = 1, so AM = 1)</h1>
      <span class="badge mono">a + b = 2</span>
    </div>

    <!-- Coordinates:
         diameter from x=0 to x=2. center O=(1,0). top T=(1,-1) (SVG y down).
         upper semicircle: (x-1)^2 + y^2 = 1 with y <= 0.
    -->
    <svg viewBox="-0.2 -1.25 2.4 1.55" aria-label="Pythagorean means (Wikipedia-style)">
      <!-- baseline + semicircle -->
      <line x1="0" y1="0" x2="2" y2="0" stroke="#111" stroke-width="0.02"/>
      <path d="M 0 0 A 1 1 0 0 1 2 0" fill="none" stroke="#111" stroke-width="0.02"/>

      <!-- end ticks -->
      <line x1="0" y1="0" x2="0" y2="0.06" stroke="#111" stroke-width="0.02"/>
      <line x1="2" y1="0" x2="2" y2="0.06" stroke="#111" stroke-width="0.02"/>

      <!-- dynamic drawing group -->
      <g id="dyn"></g>

      <!-- bottom 'a' and 'b' labels (positions updated in JS) -->
      <text id="aLabel" x="0.5" y="0.14" class="mono" font-size="0.09" fill="#000" text-anchor="middle">a</text>
      <text id="bLabelSvg" x="1.5" y="0.14" class="mono" font-size="0.09" fill="#000" text-anchor="middle">b</text>
    </svg>

    <div class="row" style="margin-top:10px;">
      <label for="bRange">Move b:</label>
      <input id="bRange" type="range" min="0.05" max="1.95" step="0.001" value="0.353" />
      <span class="mono" id="abReadout"></span>
    </div>

    <div class="hint">
      Thales helper: center <span class="mono">O=(1,0)</span>, split <span class="mono">C=(a,0)</span>.
      Thales circle has diameter <span class="mono">OC</span> (dashed). It meets chord <span class="mono">TC</span> at <span class="mono">P</span>
      (so <span class="mono">∠OPC = 90°</span>). In this diagram:
      <span style="color:#e11d48">A</span>=AM, <span style="color:#2563eb">G</span>=GM, <span style="color:#16a34a">Q</span>=QM, <span style="color:#d946ef">H</span>=HM.
    </div>
  </div>

  <!-- RIGHT: values -->
  <div class="card">
    <h1>Values & formulas</h1>
    <div class="kv mono">
      <div>a</div><div id="aVal"></div>
      <div>b</div><div id="bVal"></div>
      <div>A (AM)</div><div id="AVal"></div>
      <div>G (GM)</div><div id="GVal"></div>
      <div>H (HM)</div><div id="HVal"></div>
      <div>Q (QM/RMS)</div><div id="QVal"></div>
    </div>

    <hr style="border:none;border-top:1px solid #eee; margin:12px 0;" />
    <div class="eq mono" id="eqBlock"></div>
  </div>
</div>

<script>
(() => {
  const svgNS = "http://www.w3.org/2000/svg";
  const dyn = document.getElementById("dyn");
  const bRange = document.getElementById("bRange");
  const abReadout = document.getElementById("abReadout");

  const aLabel = document.getElementById("aLabel");
  const bLabelSvg = document.getElementById("bLabelSvg");

  const aVal = document.getElementById("aVal");
  const bVal = document.getElementById("bVal");
  const AVal = document.getElementById("AVal");
  const GVal = document.getElementById("GVal");
  const HVal = document.getElementById("HVal");
  const QVal = document.getElementById("QVal");
  const eqBlock = document.getElementById("eqBlock");

  // fixed semicircle
  const O = { x: 1, y: 0 };
  const T = { x: 1, y: -1 }; // top

  // helpers
  const el = (name, attrs={}) => {
    const n = document.createElementNS(svgNS, name);
    for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, v);
    return n;
  };
  const clear = (node) => { while(node.firstChild) node.removeChild(node.firstChild); };
  const fmt = (x) => (Math.round(x*1000)/1000).toFixed(3);

  function yOnUpperArc(x){
    const v = 1 - (x - 1) * (x - 1);
    return -Math.sqrt(Math.max(0, v));
  }

  // intersect line with circle; choose intersection in upper half (y <= 0).
  function intersectLineCircleUpper(P1, P2, C, R){
    const dx = P2.x - P1.x, dy = P2.y - P1.y;
    const fx = P1.x - C.x, fy = P1.y - C.y;

    const A = dx*dx + dy*dy;
    const B = 2*(fx*dx + fy*dy);
    const CC = fx*fx + fy*fy - R*R;

    const disc = B*B - 4*A*CC;
    if (disc < 0) return null;
    const s = Math.sqrt(disc);
    const t1 = (-B + s) / (2*A);
    const t2 = (-B - s) / (2*A);

    const I1 = { x: P1.x + t1*dx, y: P1.y + t1*dy };
    const I2 = { x: P1.x + t2*dx, y: P1.y + t2*dy };
    const candidates = [I1, I2].filter(p => p.y <= 1e-9);
    if (candidates.length === 0) return null;

    // prefer the intersection that is not the endpoint C (farthest from P2)
    const dist2 = (p,q) => (p.x-q.x)**2 + (p.y-q.y)**2;
    candidates.sort((p,q)=> dist2(q,P2) - dist2(p,P2));
    return candidates[0];
  }

  // small right-angle marker path
  function rightAngleMarker(V, A, B, size=0.06){
    const ux1 = A.x - V.x, uy1 = A.y - V.y;
    const ux2 = B.x - V.x, uy2 = B.y - V.y;
    const n1 = Math.hypot(ux1, uy1) || 1;
    const n2 = Math.hypot(ux2, uy2) || 1;
    const v1 = { x: ux1/n1, y: uy1/n1 };
    const v2 = { x: ux2/n2, y: uy2/n2 };

    const p1 = { x: V.x + v1.x*size, y: V.y + v1.y*size };
    const p2 = { x: p1.x + v2.x*size, y: p1.y + v2.y*size };
    const p3 = { x: V.x + v2.x*size, y: V.y + v2.y*size };

    return `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y} L ${p3.x} ${p3.y}`;
  }

  function update(){
    const b = parseFloat(bRange.value);
    const a = 2 - b;                 // enforce AM = 1

    // means (numeric)
    const A = 1;
    const G = Math.sqrt(a*b);
    const H = (2*a*b)/(a+b);        // (equals ab because a+b=2)
    const Q = Math.sqrt((a*a + b*b)/2);

    // points
    const C = { x: a, y: 0 };
    const Gtop = { x: C.x, y: yOnUpperArc(C.x) };

    // Thales circle (diameter OC)
    const Mth = { x: (O.x + C.x)/2, y: 0 };
    const Rth = Math.abs(C.x - O.x)/2;

    // Find intersection P of chord T->C with Thales circle (upper half).
    // If Thales radius is degenerate (a ~ 1), choose P = T for stable symmetric case.
    let P = null;
    if (Rth < 1e-6) {
      P = { x: T.x, y: T.y };
    } else {
      P = intersectLineCircleUpper(T, C, Mth, Rth) || { x: T.x, y: T.y };
    }

    // Clear dynamic layer first (so we draw everything anew in correct order)
    clear(dyn);

    // draw split tick
    dyn.appendChild(el("line",{ x1:C.x, y1:0, x2:C.x, y2:0.06, stroke:"#111", "stroke-width":"0.02" }));

    // draw Thales circle (dashed) behind helpers
    if (Rth > 1e-6){
      dyn.appendChild(el("circle",{
        cx: Mth.x, cy: Mth.y, r: Rth,
        fill: "none", stroke:"#111", "stroke-width":"0.012",
        "stroke-dasharray":"0.04 0.04", opacity:0.55
      }));
    } else {
      // degenerate: optionally draw a small faint marker at center if you like (skip for clarity)
    }

    // Points: O, C, T
    dyn.appendChild(el("circle",{ cx: O.x, cy: O.y, r: 0.016, fill: "#111" }));
    dyn.appendChild(el("circle",{ cx: C.x, cy: C.y, r: 0.016, fill: "#111" }));
    dyn.appendChild(el("circle",{ cx: T.x, cy: T.y, r: 0.016, fill: "#111" }));

    // A (red): radius OT (vertical)
    dyn.appendChild(el("line",{ x1: O.x, y1: O.y, x2: T.x, y2: T.y, stroke:"#e11d48", "stroke-width":"0.03" }));
    dyn.appendChild(el("text",{ x: O.x+0.03, y:-0.55, fill:"#e11d48", "font-size":"0.12", class:"mono" })).textContent = "A";

    // G (blue): vertical from C up to arc
    dyn.appendChild(el("line",{ x1: C.x, y1: 0, x2: Gtop.x, y2: Gtop.y, stroke:"#2563eb", "stroke-width":"0.03" }));
    dyn.appendChild(el("text",{ x: C.x+0.03, y: (Gtop.y)/2, fill:"#2563eb", "font-size":"0.12", class:"mono" })).textContent = "G";

    // Q (green): chord T -> C
    dyn.appendChild(el("line",{ x1: T.x, y1: T.y, x2: C.x, y2: C.y, stroke:"#16a34a", "stroke-width":"0.03" }));
    dyn.appendChild(el("text",{
      x: (T.x + C.x)/2 + 0.02,
      y: (T.y + C.y)/2 - 0.02,
      fill:"#16a34a", "font-size":"0.12", class:"mono"
    })).textContent = "Q";

    // H (magenta): EXACT Wikipedia construction -> segment P->C
    if (P){
      dyn.appendChild(el("line",{ x1: P.x, y1: P.y, x2: C.x, y2: C.y, stroke:"#d946ef", "stroke-width":"0.03" }));
      dyn.appendChild(el("text", {
        x: (P.x + C.x)/2 + 0.02,
        y: (P.y + C.y)/2 - 0.02,
        fill:"#d946ef", "font-size":"0.12", class:"mono"
      })).textContent = "H";
    }

    // draw helper triangle: OC diagonal, O->P and P->C, and right-angle marker at P
    if (P){
      // diagonal OC (thin)
      dyn.appendChild(el("line",{ x1: O.x, y1: O.y, x2: C.x, y2: C.y, stroke:"#111", "stroke-width":"0.015" }));

      // OP and PC (helper edges)
      dyn.appendChild(el("line",{ x1: O.x, y1: O.y, x2: P.x, y2: P.y, stroke:"#111", "stroke-width":"0.015" }));
      dyn.appendChild(el("line",{ x1: P.x, y1: P.y, x2: C.x, y2: C.y, stroke:"#111", "stroke-width":"0.015" }));

      // right-angle marker
      dyn.appendChild(el("path",{ d: rightAngleMarker(P, O, C, 0.06), fill:"none", stroke:"#111", "stroke-width":"0.01" }));

      // point P marker
      dyn.appendChild(el("circle",{ cx: P.x, cy: P.y, r: 0.012, fill:"#111" }));
    }

    // UI text updates
    abReadout.textContent = `b=${fmt(b)} (a=${fmt(a)})`;
    aVal.textContent = fmt(a);
    bVal.textContent = fmt(b);
    AVal.textContent = fmt(A);
    GVal.textContent = fmt(G);
    HVal.textContent = fmt(H);
    QVal.textContent = fmt(Q);

    eqBlock.textContent =
      `AM  A = (a + b)/2 = 1\n` +
      `GM  G = √(ab)\n` +
      `HM  H = 2ab/(a+b)\n` +
      `QM  Q = √((a² + b²)/2)\n` +
      `Construction: Q = chord TC, H = PC (Thales intersection)\n`;

    // adjust bottom label positions
    aLabel.setAttribute("x", (0 + a)/2);
    bLabelSvg.setAttribute("x", (a + 2)/2);
  }

  bRange.addEventListener("input", update, { passive:true });
  update();
})();
</script>
</body>
</html>

